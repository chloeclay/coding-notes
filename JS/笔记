1. 特点
    - 解释型语言
    - 类似于C和Java的语法结构
    - 动态语言
    - 基于原型的面向对象
        
2. 书写位置
    - button标签的onclick属性中
    - a标签的href属性中
        <a href="javascript:;"> link </a>  ;//可以让超链接点击无效
    - script标签中 </body>前 或 </head>前

3. 基本语法
    1. JS中严格区分大小写
    2. JS中每条语句以分号；结尾
        "如果不写分号，浏览器会自动添加，但消耗系统资源，且有时会加错，所以必须写"
    3. JS中会自动忽略空格和换行 -> 可以对代码进行格式化

4. 字面量&变量
    1. 字面量：常量，不可改变的值。可直接使用。但一般不会直接使用，不方便。
    2. 变量：用来保存字面量，可任意改变。更方便使用。

5. 标识符
    1. 标识符中可以且只可以含有字母、数字、_、$
    2. 不能以数字开头
    3. 不能是ES中的关键字或保留字符
        "关键字"
        break	do	  instanceof  	typeof	case
        else	new	   var	 catch  	finally
        return	vold	continue   for	switch
        while	default  if	  throw 	delete
        in	 try	 function	this	with
        debugger	false	true	null
        "保留字符"
        class	enum	extends 	super	const	export
        import	implements	let	  private	public	yield
        interface	package	  protected	  static

6. 数据类型
    (1) - 基本数据类型（Number，String，Boolean，Undefined，Null）
        - 引用数据类型（Object）
        
    (2) - 值类型（Number，String，Boolean，Null，Undefined，Symbol）
            · String: 字符串
                var str1 = "string1";
                var str2 = 'string2';
                var str3 = `string3`;
                    - "引号不能嵌套：双引号中不能放双引号，单引号中不能放单引号，但可以外双内单" 
                    var str = "She said, 'You're beautiful!'";
                    - "在字符串中，用\作为转义字符"
                        \" = "
                        \' = '
                        \n = 换行
                        \t = 制表符
                        \\ = \
                        \\\\ = \\
            · Number: 数字
                - "infinity/-infinity/NaN 类型均为Number"
                - 数字最大值：Number.MAX_VALUE
                - 数字最小正值：Number.MIN_VALUE （最小正值）
                - "NaN": not a number -> 特殊数值：非法数字；但type依旧属于number
                - 浮点运算不精确
            · Boolean: 布尔值 true false
            · Null: 空值
                - "Null类型为Object"
                - "专门用来表示一个为空的对象"
            · Undefined: 未定义  
                - "当声明一个变量，而不给它赋值时，它的值为undefined"
                - "typeof Undefined -> Undefined"
            · Symbol: ES6中新增的原始数据类型，表示独一无二的值

        - 引用数据类型（Object，Array，Function）
            Object: 对象
                var obj = {name: "Chloe"};
                console.log(typeof obj); // Object
            Array: 数组
                var arr = [1, 2, 3, 4, "a", {}];
                console.log(typeof arr); // Object
            Function：函数
                function func(){};
                console.log(typeof func); // Function

        *栈（内存）：值类型
        *堆（内存）：引用类型

    (3) 数据类型的判断
        typeof: 用于获取一个变量或表达式的数据类型
        instanceof：用于判断一个引用类型属于哪种类型（区分Array和Object）
            a instanceof Array; // 前者是否是后者的引用

    (4) 数据类型的转换
        a) 显性
            Number(变量); // 将变量转换为数字类型
            String(变量); // 将变量转换为字符串类型
                             String(true); // true
                             String(false); // false
            Boolean(变量); // 将变量转换为布尔值类型
                              除 0 "" '' null undefined NaN外均为true
            parseFloat(变量); // 将变量转换为浮点（小数）类型
            parseInt(变量); // 将变量转换为整数类型
                               会截取前半部分的数字进行运算，若首位为非数字则输出NaN
        b) 隐性   "强制类型转换"
            1. 转换为string
                1) 调用被转换数据类型的toString()方法 
                  "null 和 undefined 不能用"
                  "不影响原变量 只返回转换的结果"
                  var a = 123;
                  var b = a.toString(); // "123"
                2) 调用String()函数，并将被转换的数据作为参数传递给函数
                3) +"" 
            2. 转换为number
                1）使用Number()函数
                   " - string -> number
                        1. 纯数字字符串会被直接转换成数字
                        2. 如果有非数字的内容，则转换成NaN
                        3. 如果字符串为空串/全是空格，则转换成0
                     - boolean -> number
                        1. true -> 1
                        2. false -> 0
                     - null -> number
                        转换成0
                     - undefined -> number
                        转换成NaN
                   "
                2) 专门用来对付string：
                    - parseInt() 把一个字符串中的有效整数内容转换为number（截止到第一个非数字之前）
                    - parseFloat() 把一个字符串转换为一个浮点数（只截取有效小数）
                    "对非string使用parseInt()和parseFloat()时，会先转成string再操作"
                3) 其他进制的数字
                    - "16进制 -> 0x开头"
                        a = 0x10; //16
                        a = 0xff; //255
                        a = 0xCafe; //51966
                    - "8进制 -> 0开头"
                        a = 070; //56
                    - "2进制 -> 0b开头"
                        a = 0b10; //56
                    - "像 070 这种字符串，有些浏览器当成8进制，有些当成10进制" 
                       -> "在parseInt()中传递第二参数，来指定数字的进制"
                          a = 070;
                          a = parseInt(a,10);
                          console.log(typeof a); //number
                          console.log(a); //70
                4) 利用 -0  *1  /1  + 将任何值转换为number类型，原理=Number() 函数
            3. 转换为boolean
                1) 调用Boolean()函数：
                    - string -> boolean: 除了空串，其余都是true
                    - number -> boolean: 除了0和NaN，其余都是true
                    - null/undefined -> boolean：都为false
                    - object对象 -> boolean: 都是true
                2) 利用!!(非)进行两次取反，转换为Boolean

7. 运算符 
    (1) 赋值运算符：变量 = 值
    (2) 算术运算符：+ - * / %(取余or取模)
        - "当对非number类型的值进行运算时（字符串加法除外），会转换为number然后运算"
        - "任何值和字符串做加法运算，都会先变成字符串，再拼串" -> "可以利用 +"" 将任意数据类型转换为string"
        - "任何值和NaN进行运算结果都为NaN"
             result = true + false; // 1
             result = null + 2; // 2
             result = undefined + 3; // NaN
             result = NaN + 3; // NaN
             result = 123 + "1"; // "1231"
             result = 1 + 2 + "3"; // "33"
             result = "1" + 2 + 3; // "123"
             result = 20 / false; // Infinity
             result = 120 * null; // 0
             result = 2 * undefined; // NaN
    (3) 逻辑运算符：
        a) &&（与）-> 找"false"
            - 对符号两侧的值进行运算并返回结果，只要有1个值为false就返回false，其余为true
            - 只要第一个值为false就不会运算第二个值
            - 对非布尔值进行&&与运算时:
                "先转换成布尔值再运算，并返回原值"
                 var result = 1 && 2; // 2
                 var result = NaN && 0; // NaN
        b) ||（或） -> 找"true"
            - 对符号两侧的值进行运算并返回结果，只要有1个值为true就返回true，其余为false
            - 只要第一个值为true就不会运算第二个值
            - 对非布尔值进行||或运算时:
                "先转换成布尔值再运算，并返回原值"
                 var result = 1 || 2; // 1
                 var result = NaN || 0; // 0
                 var result = "" || "Hello"; // "Hello"
        c) !（非）
            - 进行取反操作，false -> true, true -> false
            - 对非布尔值进行取反，会先转为Boolean后再取反
            - 两次取反不会变化，但数据类型会转换为Boolean
            - 取反值为true："undefined null false 0 NaN 空字符串"
    (4) 比较运算符：> < >= <= == != === !==
        - "结果返回布尔值 true false"
        - "非数值情况： 先转换为number再比较"
        - "任何值和NaN做任何比较都为false"
            console.log(1 > true); // false
            console.log(10 > null); // true
            console.log(10 > undefined); // false
        - "若符号两侧均为string，不会将其转换成number，而会分别比较字符串中字符的Unicode编码"
           比较Unicode编码时一位一位进行比较，若第一位相同，则比较下一位 
               -> 可用于英文排序 
               -> 给其中一项加+转换成数字
               -> JS输出格式："\uUnicode编码"
               -> 网页输出格式：&#十进制编码;
            console.log("a" < "b"); // true
            console.log("abc" < "b"); // true  
        - ==（相等运算符）
            - 大部分做转换为number的类型转换
            - 比较两个值是否相等，返回true false
                console.log(true == "1");  // true
                console.log("true" == "1"); // false 因为非数字string转换成了NaN
         "***"  console.log(null == 0); // false
            - undefined 衍生自 null，所以相等会返回true，但全等返回false
                console.log(undefined == null); // true
            - "NaN 不和任何值相等，包括它本身"
                console.log(NaN == NaN); // false
                    "判断一个值是否是NaN 可以利用 isNaN() 函数"
                       var b = NaN;
                       console.log(isNaN(b)); // true
        - !=（不相等运算符）：和相等运算符相反
        - ===（全等运算符）：用来判断两个值是否全等，和相等类似，但"不做类型转换" -> 类型不同就false
        - !==（不全等运算符）：用来判断两个值是否全等，和不等类似，但"不做类型转换" -> 类型不同就true
            console.log(null === undefined); // false
            console.log(1 !== "1"); // true
    (5) 一元运算符
        a) + : 正号不会对数字产生影响，但会使其数据类型变成Number
        b) - : 对数字进行取反/先转换成Number然后再进行取反
               var result = 1 + +"2" + 3; // 6
        c) ++ : 自增  
        d) -- : 自减
            var a = 10;
            console.log(a++); // 10  
            console.log(++a); // 11  
                · " a++与++a都会使a本身的值+1，但a++当下不变，++a当下就变"
        e) typeof()：获得值的类型并以字符串形式返回
    (6) 二元运算符
        += -= *= /= %=
            var num = 10;
            num += 20; // num = num + 20;
    (7) 三元运算符（条件运算符）
        条件?条件为true时执行的代码:条件为false时执行的代码
        "先对条件表达式进行求值（非布尔值会转换成布尔值再执行）"
            var age = 10;
            age > 20 ? console.log("年龄大于20岁"):console.log("年龄小于等于20岁")；
    (8) 运算符的应用
            a）拼接字符串 + 和 +=
                var str = "Bonjour ";
                var str2 = "tout le monde.";
                str += str2;
                console.log(str); // Bonjour tout le monde.
            b）数据类型强制转换 - * / % -= *= /= %= ++ -- > < >= <= ==
                var str3 = "30";
                console.log(typeof str3++); // number
    (9) 运算符优先级
        ! > 算数 > 比较 > 逻辑 > 三元 > 赋值
            var rs = 7 > 5 && 15 > 11; // true
                "运算符优先表，位置越上越优先"
                    . [] ()	字段访问、数组下标、函数调用以及表达式分组
                    ++ -- - ~ ! delete new typeof void	一元运算符、返回数据类型、对象创建、未定义值
                    * / %	乘法、除法、取模
                    + - +	加法、减法、字符串连接
                    << >> >>>	移位
                    < <= > >= instanceof	小于、小于等于、大于、大于等于、instanceof
                    == != === !==	等于、不等于、严格相等、非严格相等
                    &	按位与
                    ^	按位或
                    |	按位或
                    &&	逻辑与
                    ||	逻辑或
                    ?:	条件
                    = oP=	赋值、运算赋值
                    ,	多重求值
    (10) Unicode编码表
        - 在字符串中使用转义字符输出特殊符号："\u + 4位Unicode编码"
        - 在网页中使用Unicode编码："&# + 10进制编码;"

8. 代码块
    - statement语句：程序是由一条条语句构成的
      - 执行顺序：自上至下
      - 可使用{}将语句进行分组
        同一个{}中的语句为一组/一个代码块，要么都执行，要么都不执行
            {
                alert("hello"); 
                console.log("bonjour");
                document.write("statement");
            }

9. 初级事件绑定
    (1) HTML事件：
            · 发生在HTML元素上的事，在页面中使用JS时可以触发
            · HTML事件可以是浏览器行为，也可以是用户行为
                浏览器：
                - window.onload = function(){}; // 入口函数
                用户：
                - onchange; // HTML元素改变 表单元素
                - oninput; // 表单输入事件
                - onclick; // 点击
                - onmouseover; // 鼠标移动至元素上
                - onmouseout; // 鼠标移出元素上
                - onkeydown; // 按下键
                    ex：onclick = "javascript: alert("Bonjour")"
                        var oBtn = document.getElementById("btn");
                        oBtn.onclick = alert("Bonjour");
            · 如何获取HTML元素：
                通过id名获取 document.getElementById("id");

10. 分支循环(流程控制)
    (1) 分支：条件语句，基于不同条件执行不同动作
        - if...else语句
            · if 语句：只有当指定条件为true时执行代码
                "if(条件){执行代码};"
            · if...else 语句：条件为true时执行代码，为false时执行其他代码
                "if(){}else{};"
            · if...else if...else 语句：选择多个代码块之一执行
                "if(){}else if(){}else{};"
                    var oDay = (new Date()).getDay();
                    console.log(oDay);
                    if(oDay == 1){
                        console.log("Aujourd'hui est lundi.")
                    }else if(oDay == 2){
                        console.log("Aujourd'hui est mardi.")
                    }else if(oDay == 3){
                        console.log("Aujourd'hui est mercredi.")
                    }else{
                        console.log("懒得继续打了但你get到了就好")
                    }

        - switch语句
            · 对比swtich变量和case值是否"全等"，从上向下执行，遇break停
            · 如果所有比较结果都为false则执行default代码
            · switch(key/变量){
                case"值1":
                case"值2":
                case"值3":
                    执行代码;
                    break;
                ...
                default:
                    执行代码;
                    break;
            }
    (2) 循环
        - for循环
            · for...in遍历
            · for(初始化表达式; 条件表达式; 更新表达式){
                执行代码;
            }
                    1. 初始化表达式（只执行一次）
                    2. 执行条件表达式，判断是否执行循环
                    3. true -> 执行语句
                       false -> 终止语句
                    4. 更新表达式
                    5. 执行条件表达式，判断是否执行循环
                    6. true -> 执行语句
                       false -> 终止语句
                    7. 更新表达式
                 ...
            · "for循环中的三个部分都可以被省略，也可以写在外部"
            · "for(;;)  -> 死循环"
        - while循环
            · 先对条件表达式进行判断
                true -> 执行循环体 -> 判断 -> 执行循环体
                false -> 终止循环体
            · while(条件表达式){
                执行代码;
                更新表达式;
            }
            · 步骤：
                     1. 初始化一个变量
                     2. 在循环中设置一个条件表达式
                     3. 定义一个新的表达式，每次更新初始化变量
            · do{
                执行代码;
            }while(条件表达式);
                "do while先执行循环再判断" -> 保证循环体至少执行一次
    (3) break和continue
        · break用于终止switch和循环语句，不可用于if语句，只影响离得最近的循环语句
            -> "为循环创建label 起名"
                outer: -> 该循环名为outer
                for(;;){
                    for(;;){
                        break outer;
                    }
                }
        · continue用于跳过当次循环

11. 对象 Object
    (0) 分类：
        1）内建对象：ES标准中定义的对象，任意ES实现中都可使用 "Math String Function Object"
        2）宿主对象：JS运行环境（浏览器）提供的对象 "BOM浏览器对象模型 DOM文档对象模型"
        3）自建对象：开发人员自定义的对象
    (1) 定义：
        · Object：以"键值对"形式存储属性的集合，每个属性有一个特定的名称，以及与名称相对应的值
        · 这种关系有一个专有名称："映射"
        · 除了可以通过这种方式保持自由属性，还可通过继承的方式继承属性，这种方式称为"原型式继承"
        · "对象即为拥有属性和方法的数据" "万物皆对象"
        · ; {key:value, key:value, key: value,...}
    (2) 声明：
        · 通过 "new" 关键字构造函数（constructor）
          var obj = new Object();
          console.log(obj); // Object{} ->说明是一个对象
        · 通过 "字面量" 声明 {}
          var personne = {
              name: "Chloe",
              age: 12,
              hobby: function(){
                  return "Manger, Apprendre, Dormir";
              }
          }
        · 添加属性： 
            ; 对象.属性名 = 属性值 
            ; 对象["属性名"] = 属性值
            obj.name = "Chloe";
            obj["age"] = 12;
            obj.func = function(){
                return "Manger, Apprendre, Dormir";
            }
        · 删除属性：
            ; delete 对象.属性名
    (3) 访问：
        1）访问属性（与对象相关的值）
            ; object.property "对象.属性名"
            ; object[""]
             console.log(personne.name); // Chloe
             console.log(personne["age"]); // 12
        2）访问方法（在对象上可以执行的动作）
            ; object.method()
             console.log(personne.hobby()); // Manger, Apprendre, Dormir
    (4) 检查：
        · 对象中是否有指定属性：
            ;in 运算符
                · "属性名" in 对象
                  console.log("name" in personne); // true
    (5) 注意事项：
        1）对象可以嵌套对象 -> "对象的值也可以是对象"
            var oceane = {
                name: "Oceane",
                age: 24,
                bestFriend:{
                    name: "Chloe", "Vanessa"
                    age: 25
                }
            }
            console.log(oceane.bestFriend); //  name: "Chloe", age: 24
        2）对象的属性具有唯一性 -> "相同属性，后边覆盖前边"
        3）对象的键必须是"字符串"数据类型
            ; 非String类型会被强制转换
            var a = {name:"a"};
            var b = {name:"b"};
            var c = [1,2,3];
            var obj = {};
            obj[a] = 10;
            console.log(obj); // [object object]:10
            obj[b] = 20;
            console.log(obj); // [object object]:20 -> 覆盖
            obj[c] = 30;
            console.log(obj);
            console.log(obj[a]); // 20
        4) 对象的遍历   "for...in"循环
            ; 创建对象
            var personne = {
                name: Oceane,
                age: 24,
                hobby: function(){
                    console.log("Dormir");
                }
            }
                "更严谨的写法："
                var personne = Object.create({});
            ; 对象的遍历
              "有几个属性就循环几次，每次都把属性名赋值给key变量"
                for(key in personne){
                    console.log(key, personne[key]);
                    personne[key]();
                }
                    - "hasOwnProperty"  检测属性
                        · 对象.hasOwnProperty("检测的属性");
                    - "in"  检测属性
                        · if("检测的属性" in personne){
                            console.log("有检测的属性");
                        }else{
                            console.log("无检测的属性");
                        }
        5) 栈与堆：
            - 基本数据类型的值直接在"栈内存"中存储，值与值之间相互独立，修改一个变量不影响其他变量的值 ; 表格（变量+值）
            - 对象保存在"堆内存"中，每创建一个对象就会在堆内存中开辟一个新的空间。变量保存的是对象的内存地址（对象的引用），当两个变量保存的是同一个对象引用时，其中一个通过变量修改属性则另一个也随之更改。; 空间
                var a = 123, b = a;
                a++;
                console.log(b); // 123
                console.log(a); // 124
                ----------------
                var obj = new Object();
                obj["name"] = "Chloe";
                var obj2 = obj;
                obj["name"] = "Oceanne";
                console.log(obj2.name); // Oceanne
                obj = null;
                console.log(obj2); // object
                -----------------
                var obj3 = {name: "Chloe"};
                var obj4 = {name: "Chloe"};
                console.log(obj3 == obj4); // false
                    -> "当比较两个基本数据类型时，比较的是值；比较两个引用数据类型时，比较的是内存地址"
        6) 批量创建对象：利用工厂方法
                    function createPerson(name, age, gender) {
                    var obj = new Object();
                        obj.name = name,
                        obj.age = age,
                        obj.gender = gender,
                        obj.sayName = function () {
                            console.log(this.name);
                        }
                    return obj;
                    }
                    var obj1 = createPerson("Chloe", 25, "femme");
                    var obj2 = createPerson("Oceanne", 24, "femme");
                    var obj3 = createPerson("Vanessa", 25, "femme");
                    console.log(obj1, obj2, obj3);
                    obj1.sayName(); // Chloe

12. 函数
    (1) 定义+语法：
        - 执行特定任务的，可重复使用的代码块，属于对象的一种
        - 由"函数名、参数、函数体、返回值"4部分构成
        - 声明：
            1) 通过"new"关键字构造函数，以字符串的形势把代码传递给构造函数
                ; var func = new Function("要执行的代码");
            2) 通过"function"关键字声明，通过"函数名();"调用
                "()表示立即调用函数"
                ;  function 函数名([形参1, 形参2...形参N]){
                ;     函数体;
                ;     return 返回值
                ;  }
                ;  函数名();
            3) 通过"函数表达式"创建函数
                ;  var 函数名 = function([形参1, 形参2...形参N]){
                ;               函数体;
                ;               return 返回值
                ;               };
                ;  函数名();
        - 参数：
            · 在函数的()中指定一个或多个形式参数，用逗号隔开，相当于在函数内部声明了对应的变量，但不赋值
            · 调用函数时，在()中指定实际参数，相当于赋值
            · 解析器不检查实参类型&数量 -> 可能接收到非法参数
                                      -> 实参可以为"任意数据类型"，包括对象和函数
                                      -> 实参个数与形参不同时，多的不看，少的"undefined"
        - 返回值：
            · 函数的返回结果，可以返回"任意数据类型"的值，但不做任何操作
            · 不写return或return后不接任何值，则会返回"undefined"
            · return后的语句不会执行
    (2) 分类：
        - 根据有无"函数名"分类：
            · 命名函数
            · 匿名函数
                ;  变量储存函数 
                    var func = function(){
                        console.log("这是一个变量储存匿名函数");
                    }
                    ;  调用方法：func();
                ;  事件调用函数 
                    document.onclick = function(){
                        console.log("这是一个事件调用匿名函数");
                    }
                    ;  调用方法：执行事件
                        var oBtn = document.getElementsById("btn");
                        oBtn.onclick = func;
                ;  自执行函数/立即执行函数 一般只执行一次
                    (function(){
                        console.log("自执行函数");
                    })();
        - 根据有无"参数"分类：
            · 传参函数：()中有参数
                function add(x,y){
                    console.log(x + y); // x、y为形参
                }
                add(1,4); // 1、4为实参
            · 无参函数：()中无参数
        - 带有"返回值"的函数：
            · 返回"函数执行的结果"
            · function add(x,y){
                if(x > y){
                    return x - y; // return之后函数停止执行
                }
                console.log(x + y);
              }
               console.log(add(2,4)); // 6
               console.log(add(6,4)); // 2
    (3) 作用域：变量的作用范围
        - 全局作用域
            · 在函数外定义的变量为全局变量，全局变量有全局作用域："网页中所有脚本和函数都可以使用"
            · 网页打开时创建，关闭时销毁
            · 全局作用域中创建的变量会作为"全局对象window"的属性保存，函数作为方法保存
                ; 变量的声明提前：
                    - 使用"var"关键字声明的变量会在所有代码执行前被声明，但不赋值；不使用var关键字则不会被声明提前
                        console.log(a); // 正常执行
                        var a = 1;
                ; 函数的声明提前：
                    - 使用"function"关键字声明的函数会在所有代码执行前被创建，可以提前调用；使用"函数表达式"创建的函数不会被声明提前
                        func(); // 正常执行
                        function func(){} 
        - 局部（函数）作用域
            · 调用函数时创建函数作用域，执行完毕后销毁
            · 每调用一次创建一个作用域，相互独立
            · 只能在函数内部访问
              function func(){
                  var a = 10;
                  function min(){
                      console.log(a);
                  }
                  min(); // 正常执行 不会报错
              }
              func();
              console.log(a); // not defined 未声明
            · "子对象可以一级一级地向上寻找父对象的变量" -> "父对象中所有变量对子对象都可见"
            · 在函数中不使用var声明的变量会成为全局变量（自动作为window的属性）
                var a = 1;
                function func(){
                    a = 10;
                }
                func();
                console.log(a); // 10
            · 涉及到参数：
                var a = 10;
                function func(a){
                    console.log(a); // undefined
                }
                func();
    (4) 变量的生命周期
        · JS的变量生命周期在声明时初始化 
        ·" 局部变量在函数执行完毕后销毁"
        · "全局变量在页面关闭后销毁"
    (5) 闭包含数
        · 闭包含数是一个拥有许多变量和绑定了这些变量的环境（作用域）的表达式（通常是一个函数）
        · "在函数外可以获取到局部变量"
          function func(){
              var a = 10;
              return (function(){
                  return a;
              })();
          }
          console.log(func()); // 利用自执行函数获取a的值
          ;// 在函数内声明计数器：
          var add = (function(){
              var a = 0;
              return function(){
                  return a += 1;
              }
          })();
        · "可以让一个变量的值始终保存在内存中" -> "函数执行完毕后不销毁"
          function func(){
              var a = 10;
              fAdd = function(){
                  a += 1;
              }
              return function func2(){
                  return a;
              }
          }
              var res = func(); // 此时获取到的是函数func2
              console.log(res()); // 10
              fAdd();
              console.log(res()); // 11
    (6) 隐含参数
        1) this
            · 定义：解析器每次调用函数都会向函数内部传递一个隐含参数，指向函数执行的上下文对象
            · 性质:  
                    1）以函数形式调用，this永远指window
                    2）以方法形式调用，this指调用方法的对象 -> "可以在构造函数中用this引用新建的对象"
                    3）以构造函数调用，this指新创建的对象
                    4）使用call和apply调用，this是指定的对象
                    5）事件响应函数，this是被绑定的对象
                                function func() {
                                console.log(this.name);
                                }
                                var name = "window";
                                var obj1 = {
                                    name: "obj1",
                                    fun: func
                                }
                                var obj2 = {
                                    name: "obj2",
                                    fun: func
                                }
                                func(); // window
                                obj1.fun(); // obj1
                                obj2.fun(); // obj2
        2) arguments
            · 定义：传递的隐含参数，封装"实参"的对象
            · 性质：
                    - 调用函数时，所有传递的实参都会在arguments中保存
                    - 类数组对象，可以通过索引操作，也可以通过arguments.length获取长度
                    - 自带callee属性，对应当前正在执行的函数对象
    (7) 构造函数（类）
        (1) 定义：
            · 构造函数：一个函数，是所属类的实例
            · 类：使用同一个构造函数创建的对象
        (2) 创建：和普通函数一样，但"类名首字母大写"
            function Name(){
                类的属性和方法
            }
        (3) 调用：和不同函数不同，"需要使用new关键字调用"
            function Person(name, age, sex, hobby){
                this.name = name;
                this.age = age;
                this.sex = sex;
                this.hobby = hobby; // this 在此处代表新创建的对象
            }
            ; 引用类  创建类的实例
            var chloe = new Person("Chloe", 24, "Femme", function(){console.log("Aimer dormir")});
            console.log(chloe);
        (4) 执行流程：
            1) 立即创建一个新的对象
            2) 将新创建对象设置为函数中的this "在构造函数中可以使用this来引用"
            3) 逐行执行函数中代码
            4) 将新建的对象作为返回值返回
        (5) 检查：
            · 检查实例是否属于类："实例 instanceof 类" 返回true/false
            · 检查对象自身中是否有某属性："对象.hasOwnProperty('属性名')"
        (6) 原型prototype
                - 定义：当函数以构造函数的形式调用时，所创建的对象中含有一个隐藏属性，指向构造函数的原型对象
                - 性质：相当于该类的公共区域，所有同类实例可以访问
                - 访问：__proto__
                    ; 访问对象的属性或方法时，会先在自身中寻找，没找到再去原型对象中找，还没有就去原型对象的原型中找，直到找到Object对象的原型为止
                - 添加属性或方法：
                    Person.prototype.introduction = function(){
                        console.log("Je m'appelle" + this.name);
                    }
                - 检测对象是否在另一个对象原型中 "isPrototypeOf"
                    function Person(){};
                    var chloe = new Person();
                    console.log(Person.prototype.isPrototypeOf(chloe)); // true
        (7) toString()
            · 在页面中打印对象，输出的是对象的toString()方法的返回值
            · 为类的原型添加toString()方法进行修改：
                function Person(name, age){
                    this.name = name,
                    this.age = age
                }
                Person.prototype.toString() = function(){
                    return "Person[name = " + this.name + ", age = " + this.age;
                }
                var per1 = new Person("Chloe", 25);
                var per2 = new Person("Oceanne", 24);
                console.log(per1);
    (8) 垃圾回收 GC
        不用的对象用=null进行垃圾回收
    (9) call() 和 apply()
        · 将一个对象指定为第一个参数，并使之成为函数执行的this
        · call()   将实参写在对象之后依次传递
          apply()  将实参封装到数组中统一传递
    
13. 数组对象
    (1) 定义：使用单独的变量名储存一系列的值，一个容器保存多个元素。
        var arrNames = ["Chloe", "Oceane", "Vanessa"];
        ; 元素可以为任意类型值
    (2) 创建与访问
        · 创建数组
            1）字面量 []
               var arr = [1, 2, 3, 4];
            2）常规方式：;构造函数 new关键字
              - var arr = new Array();
                arr[0] = "Chloe";
                arr[1] = "Oceane";
                arr[2] = "Vanessa";
              - var arr = new Array("Chloe", "Oceane", "Vanessa");
              "括号中只有一个数字则代表数组项的个数"
              - var arr = new Array(3);
        · 访问数组 ;数组[索引]
            console.log(arr[0]);
        · 检查数组
            Array.isArray(要检查的对象);
    (3) 属性
        - "length"：设置或返回数组元素的个数 -> "最大索引+1"
           console.log(arr.length); // 3
           arr.length = 20;
           console.log(arr); // 20 -> 超出部分为empty 多余部分会被截掉
           数组[数组.length]; 可以向数组最后一位添加元素
        - "constructor"：返回创建数组对象的原型函数
           console.log(arr.constructor); //原型函数
        - "prototype"：向数组对象添加属性或方法
                1）Array.prototype.func = function(){
                    for(var i = 0; i < 10; i++){
                        console.log(i);
                    }
                   }
                   var arr = new Array();
                   arr.func(); //方法会被调用
                2）Array.prototype.name = "String";
                   console.log(arr.name); // String
    (4) 方法
        var arr1 = [1, 2, 3];
        var arr2 = [4, 5, 6];
        var arr3 = [7, 8];
            ; concat() 
              连接两个或更多的数组并返回结果 "不改变原数组"
            ; push()
              向数组的末尾添加一个或多个元素并返回新的长度 "改变原数组" 
              console.log(arr1.push(1, 2, 3)); // 6
              console.log(arr1); // 1, 2, 3, 1, 2, 3
              console.log(arr1.concat(arr2, arr3)); // 1, 2, 3, 4, 5, 6, 7, 8
            ; unshift()
              向数组的开头添加一个或多个元素并返回新的长度 "改变原数组"
              console.log(arr1.unshift("a", "b")); // 8
              console.log(arr1); // "a", "b", 1, 2, 3, 1, 2, 3
            ; pop()
              删除并返回数组的最后一个元素 "改变原数组"
              console.log(arr3.pop()); // 8
              console.log(arr3); // 7
            ; shift()
              删除并返回数组的第一个元素 "改变原数组"
              console.log(arr2.shift()); // 4
              console.log(arr2); // 5, 6
            ; indexOf()
              搜索数组中元素并返回其第一次出现的位置 "没有该元素则返回-1"
              console.log(arr1.indexOf(2)); // 3
            ; lastIndexOf()
              搜索数组中元素并返回其最后一次出现的位置 "没有该元素则返回-1"
              console.log(arr1.lastIndexOf(2)); // 6
            ; reverse()
              反转数组的元素顺序 "改变原数组"
              console.log(arr1.reverse()); // 3, 2, 1, 3, 2, 1, "b", "a"
            ; join()
              把数组所有元素放入一个字符串 "不改变原数组"
              console.log(arr2.join()); // 5, 6
            ; slice(开始的索引,结束的索引)
              选取数组的一部分并返回一个新数组 "截取数组，留头不留尾" "不改变原数组"
              console.log(arr1(0,4)); // 3, 2, 1, 3
            ; splice(开始的索引,截取个数,添加的元素)
              从数组中添加或删除元素并返回截取部分 "改变原数组" "添加在第n个元素之前"
              console.log(arr1.splice(0, 0, "x", "y")); // []
              console.log(arr1); // "x", "y", 3, 2, 1, 2, 1, "b", "a"
            ; sort(回调函数)
              对数组元素进行ASCII排序 "改变原数组" "返回true或false"
              var arr4 = [1, 111, 10, "a", "n"];
              console.log(arr4.sort(function(a,b){
                  return a - b;
              })); // 1, 10, 111, "a", "n"
              "升序"
              console.log(arr4.sort(function(a,b){
                  return b - a;
              })); // 111, 10, 1, "a", "n"
              "降序"
            ; every(回调函数)
              检查数组元素的每个元素是否都符合条件 "返回有几个true和false"
              var arr5 = [1, 2, 3, 4, 5];
              arr5.every(function(i){
                  console.log(i > 10);
              }); // false
            ; filter(回调函数) 
              检测数值元素并返回所有符合条件的数组
              console.log(arr5.filter(function(i){
                  return i >= 3;
              })); // 3, 4, 5
            ; forEach(function(value, index, array))
              数组每个元素都执行一次回调函数
              · value：元素
              · index：索引
              · arr：当前数组
                var arr7 = [2, 2.5, 111, "x", undefined];
                arr7.forEach(function(val, index, arr){
                    console.log(val, index, arr);
                })
            ; map(函数)
              通过指定函数处理数组的每个元素并返回处理后的新数组
              console.log(arr7.map(function(i){
                  return i += 1;
              })); // 3, 3.5, 112, "x1", NaN
            ; reduce(function(total, value{}))
              将数组元素计算为一个值 "从左到右"
              console.log(arr7.reduce(function(sum, val){
                  sum += val;
                  return sum;
              })); // 115.5xundefined
            ; reduceRight(function(total, value{}))
              将数组元素计算为一个值 "从右到左"
              console.log(arr7.reduceRight(function(sum, val){
                  sum += val;
                  return sum;
              })); // undefinedx1112.52
            ; toString()
              把数组转换成字符串并返回结果
            ; valueOf()
              返回数组对象的原始值
            ; isArry()
              判断对象是否为数组
              ---------ES6新增---------
            ; find(function(val){})
              返回符合"第一个"传入测试（函数）条件的数组元素
              var arr1 = [1, 2, 3, 4, 5, 6];
              var arr2 = ["a", "b", "c", "d"];
              console.log(find(function(num){
                  return num > 3;
              })); // 4
            ; findIndex(function(val){})
              返回"第一个"符合传入测试（函数）条件的数组元素索引
              console.log(findIndex(fonction(num){
                  return num > 3;
              })); // 3
            ; copyWithin(target, start, end)
              从数组的指定位置拷贝元素到数组的另一个指定位置"留头不留尾"
              console.log(arr1.copyWithin(0, 2, 5)); // [3, 4, 5, 4, 5, 6]
            ; entries()
              返回数组的可迭代对象
              var x = arr1.entries();
              console.log(x.next().value); // [0, 3]
              console.log(x.next().value); // [1, 4]
              console.log(x.next().value); // [2, 5]
              console.log(x.next().value); // [3, 4]
              console.log(x.next().value); // [4, 5]
              console.log(x.next().value); // [5, 6]
            ; keys()
              返回数组的可迭代对象，包含原始数组的key
              var y = arr1.keys();
              for(var i = 0; i < arr1.length; i++){
                  console.log(y.next().value);
              }; // 0 1 2 3 4 5
            ; fill(val, start, end)
              使用一个固定值来填充数组
              console.log(arr2.fill("Chloe", 0, 2)); // "Chloe", "Chloe", "c", "d" 
            ; from(object, function(){})
              通过给定的对象中创建一个数组 "类数组"
              console.log(Array.from("Chloe")); // "C", "h", "l", "o", "e"
            ; includes()
              判断一个数组是否包含一个指定的值
              console.log(arr1.includes(1)); // false
    (5) 数组的遍历
        for(var i = 0; i < array.length; i++){
            console.log(array[i]);
        }
    (6) 数组中迭代的方法
        var arr1 = [0, 1, 2, 3, 4, 5];
        "value：当前项 - 必填" 
        "index：索引 - 选填" 
        "arr：数组 - 选填"
        1）; forEach(function(value, index, arr){})
             对数组的每一项运行给定函数，方法不进行返回，一般用于让数组"循环"执行某方法
               var arr2 = [];
               arr1.forEach(function(val, index, arr){
                   arr2.push(val + index);
               }); // [0, 2, 4, 6, 8, 10]
        2）; map(function(value, index, arr){})
             对数组的每一项运行给定函数，返回执行函数后的结果组成的"新数组"
                var arr3 = arr1.map(function(val, index, arr){
                    return arr += 1;
                }); // [1, 2, 3, 4, 5]
        3）; every(function(value, index, arr){})
             对数组的每一项运行给定函数，进行判断，若对于每项函数都返回"true"，则结果为"true"
                console.log(arr1.every(function(val){
                    return val > 1;
                })); // false
        4）; some(function(value, index, arr){})
             对数组的每一项运行给定函数，进行判断，若存在一项符合条件的数组项，则结果为"true"
                console.log(arr1.some(function(val){
                    return val > 1;
                })); // true
        5）; filter(function(value, index, arr){})
             对数组的每一项都运行给定函数，进行过滤，将符合条件的数组项添加到新的数组中并返回"新数组"
                var arr4 = arr1.filter(function(val){
                    return val > 3;
                });
                console.log(arr4); // [4, 5]
        6）; find()
             返回第一个符合传入测试（函数）条件的数组"元素"
                console.log(arr1.find(function(val){
                    return val > 10;
                })); // undefined
        7）; findIndex()
             返回符合传入测试（函数）条件的数组元素"索引"
                console.log(arr1.findIndex(function(val){
                    return val > 10;
                })); // -1
        8）; includes()
             判断一个数组是否包含一个指定的值
                console.log(arr1.includes(1)); // true
    (7) 数组的排序
             var arr = [1, 22, 111, "a", "A"];
        1）; sort() 
             按照ASCII排序，对数组每个项都执行"toString()"方法，得到字符串后排序
                console.log(arr.sort()); // [1, 111, 22, "A", "a"]
        2）; 给sort()添加回调函数，比较函数
             "只可以对数字进行排序，如果含有string则按照原数组位置摆放string"
             var arr1 = [11, 224, 32.2];
             function up(a, b){
                 if(a > b){
                     return 1;
                 }else if(a < b){
                     return -1;
                 }else{
                     return 0;
                 }
             }
             "或者"
             function up(a, b){
                 return a - b;
             }
             console.log(arr1.sort(up)); // [11, 32.2, 224]
        3）冒泡排序
            var arr = [24, 2332, 4, 5245, 66422, 35253, 42743, 332743, 7437, 227, 495, 9038, 325];
            for(i = 0; i < arr.length - 1; i++){
                // console.log(i);
                for (var j = 0; j < arr.length - i - 1; j++) {
                    if (arr[j] > arr[j+1]) {
                        var k;
                        k = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = k;
                    }
                }
            } -> "可进行封装后重复使用"
        4）选择排序
            for (let i = 0; i < arrMax.length - 1; i++) {
                var max = i;
                for (let j = i + 1; j < arrMax.length; j++){
                    if (arrMax[max] < arrMax[j]) {
                        max = j;
                    }
                }
                var temp = arrMax[i];
                arrMax[i] = arrMax[max];
                arrMax[max] = temp;
                console.log(arrMax);
            }
    (8) 数组去重
        1）遍历数组 -> 进行对比 -> 删除相同项 "splice()"
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    arr.splice(j, 1);
                    j--;
                }
            }
        }
        console.log(arr);
        2）遍历数组 -> 进行对比 -> 用之前不存在的项创建新数组 "push() indexOf()"
            var arrNew = [];
            for (let a = 0; a < arr.length; a++) {
                if (arrNew.indexOf(arr[a]) === -1) {
                    arrNew.push(arr[a]);
                }
            }
            console.log(arrNew);
        3）includes() 判断是否包含某个值
            var arrNew = [];
            for (let i = 0; i < arr.length; i++){
                if (!arrNew.includes(arr[i])){
                    arrNew.push(arr[i]);
                }
            }
        4）filter() 筛选值
            var arrNew = arr.filter(function(val, index, array){
                return array.indexOf(val) === index;
            })
        5）es6方法 new Set() 不可以出现相同元素
            console.log(...new Set(arr));
            console.log(Array.from(new Set(arr)));
    (9) 多维数组
        1）二维数组的创建&访问
            - var arr = [[1, 2], [3, 4, 5], [6]];
              console.log(arr[0][0]);
            - var arr = new Array();
              arr[0] = [1, 2];
              arr[1] = [3, 4, 5];
              arr[2] = [6];
        2）二维数组的遍历
            for (i = 0; i < arr.length; i++) {
                for (j = 0; j < arr[i].length; j++){
                    console.log(arr[i][j]);
                }
            }
        3）二级联动
            - 获取元素
            - 创建二维数组
            - 利用"for in遍历"和"add(new Option(text, value))"给第一层添加option
            - 利用"数组[第一层][第二层]"给第二层添加关联option
    (10) Date()对象
            · 获取某日期时间，括号内传参：month/day/year hours:minutes:seconds
                - 无参数则为代码执行日期时间
            · getDate()
                - 返回日期值
            · getDay
                - 返回星期值 （0代表星期日）
            · getMonth()
                - 返回月份值 （0代表1月）
            · getFullYear()
                - 返回完整年份
            · getTime()
                - 获取当前日期对象的"时间戳"
                - 时间戳：从格林威治标准时间开始到当前时间的总毫秒数（1970/01/01 00：00：00）
                    - 获取当前时间戳：Date.now();
                      var start = Date.now();
                      执行代码;
                      var end = Date.now();
                      console.log(end - start);
    (11) Math()对象
            · 属于工具类，不是构造函数，不用创建对象，封装了数学运算相关属性和方法
            · Math.PI ——> 常量圆周率
            · Math.abs() ——> 绝对值
            · Math.ceil() ——> 小数位只要值非0就向上取整
            · Math.floor() ——> 小数位直接舍掉
            · Math.round() ——> 四舍五入取整
            · Math.random() ——> 生成一个0-1之间的随机数
                            ——> 生成一个x-y之间的随机整数
                                Math.round(Math.random()*(y-x) + x);
            · Math.max() ——> 获取多个数中的最大值
            · Math.min() ——> 获取多个数中的最小值
            · Math.sqrt() ——> 开方
            · Math.pow(x,y) ——> 返回x的y次幂
15. 包装类（浏览器用）
    JS中提供三个包装类，可以将基本数据类型转换为对象：
        (1) String()
        (2) Number()
        (3) Boolean()
    对基本数据类型调用方法和属性时，解析器会临时使用包装类将其转换为对象，然后调用对象的方法和属性。

16. 字符串
    "以字符数组形式保存，用以处理文本"
    (1) 创建
        a）字面量 "" '' `` ;类型为string 
        b）使用new关键字 构造函数 ;类型为object
            var str = new String("STRING");
    (2) 属性
          var str = 'hello world';
        - length 字符串的长度 ;// 11
        - constructor 对创建该对象的原型函数的引用
            console.log(str.constructor); // f String(){[native code]}
        - prototype 向对象添加属性和方法
            String.prototype.func = function(){
                return this.length;
            }
            console.log(str.func()); // 11
            for(var i =0; i < str.length; i++){
                console.log(str[i]); // 打印str每一个字符
            }
    (3) 方法
        var str1 = "hello";
        var str2 = "wolrd";
        var str3 = " ";
            ; concat()  连接两个或多个字符串并返回新字符串 
              console.log(str1.concat(str3, str2));
              console.log(str1.concat(str3).concat(str2));
            ; ``  模版字符串 不用加号
              console.log(`${str1}${str2}${str3}`);
            ; indexOf("string",开始查找的位置)  返回某个指定的字符串值在字符串中首次出现的位置 
              "-1表示未查寻到"
              console.log(str1.indexOf("l")); // 2
            ; lastIndexOf()  从后向前搜索字符串 并从起始位置开始计算返回字符串最后出现的位置
              console.log(str1.lastIndexOf("l")); // 3
            ; slice()  提取字符串的片段并在新的字符串中返回被提取的部分
              "留头不留尾"
              console.log(str2(0, 3)); // wor
            ; charAt(索引)  返回在指定位置的字符
              console.log(str1.charAt(1)); // e
            ; charCodeAt(索引)  返回在指定位置字符的Unicode编码
              console.log(str1.charCodeAt(0)); // 104
            ; String.fromCharCode(字符编码)  将Unicode编码转换为字符
              console.log(String.fromCharcode(104)); // h
            ; substr(start, length)  从起始索引号提取字符串中指定数目的字符
              console.log(str2.substr(0, 2)); // wo
            ; substring(start, end)  提取字符串中两个指定的索引号之间的的字符
              "和slice()一样，但不能接收负值，且会按顺序自动调整参数位置"
              console.log(str2.substring(0, 3)); // wor
            ; split("匹配条件")  把字符串分割为字符串数组，默认全局匹配
              "可以传递正则表达式作为参数拆分"
              console.log(str1.split("")); // ["h", "e", "l", "l", "o"]
              console.log(str1.split("e")); // ["h", "llo"]
              var str = "1a2b3c4d";
              console.log(str.split(/[0-9]/)); // abcd
              console.log(str.split(/[A-z]/)); // 1234
              翻转字符：console.log(str1.split("").reverse().join(""));
            ; trim()  去除头尾空白
              console.log((" BONJOU  R  ").trim()); // BONJOU  R
            ; toLowerCase()  把字符串转换为小写
              console.log(("BONJOUR").toLowerCase()); // bonjour
            ; toUpperCase()  把字符串转换为大写
            ; toLocaleLowerCase()  根据本地主机语言环境把字符串转换为小写
            ; toLocaleUpperCase()  根据本地主机语言环境把字符串转换为大写
            ; toString()  返回一个字符串
            ; valueOf()  返回某个字符串对象的原始值
            ; search()  查找第一次与正则表达式相匹配的值
              "不能全局 只能找第一个"
              console.log(str1.search("h")); // 0
              var str = "hello adc bonjour afc"; 
              console.log(str.search(/a[bde]c/)); // 6
            ; match()  查找找到一个或多个正则表达式的匹配，并封装到数组中返回
              console.log(str1.match("l")); // 2
              console.log(str1.match(/l/g)); // ["l", "l"]
            ; replace("被替换", "替换成")  在字符串中查找匹配的子串并替换与正则表达式匹配的子串
              "默认只替换第一个 -> 可以接收正则表达式"
              console.log(str1.replace("e", "a")); // hallo
            ; replaceAll()  在字符串中查找匹配的子串并替换与正则表达式匹配的所有子串
              console.log(("aabbaa").replaceAll("a", "A")); // AAbbAA
            ======================== ES 6 =======================
            ; includes()  查找字符串中是否包含指定的子字符串
              console.log(str1.includes("h")); // true
            ; repeat()  复制字符串指定次数并将它们连接在一起返回
              console.log(str1.repeat(2)); // hellohello
            ; startsWith()  查看字符串是否以指定的子字符串开头
              console.log(str1.startsWith("")); // true
    (4) 字符串HTML包装的方法
            ; anchor()  创建HTML锚
            ; big()  使用大号字体显示字符串
            ; blink()  显示闪动字符串
            ; bold()  使用粗体显示字符串
            ; fixed()  以打字机文本显示字符串
            ; fontcolor()  使用指定的颜色显示字符串
            ; fontsize()  使用指定的尺寸显示字符串
            ; italics()  使用斜体显示字符串
            ; link()  将字符串显示为链接
            ; small()  使用小号字体来显示字符串
            ; strike()  用于显示加删除线的字符串
            ; sub()  把字符串显示为下标
            ; sup()  把字符串显示为上标
              应用实例："返回顶部按钮"
              var str = "UP";
              document.write(str.anchor("top"));
              document.write("<br/><br/><br/><br/><br/>");
              document.write(str.link("#top"));

17. 正则表达式
    (1) 定义："给字符串定义某种规则，检查是否合规，提取合规内容"
    (2) 创建：
        a）构造函数：
                var reg = new RegExp("正则表达式","匹配模式");
                    · 正则表达式：
                        - "|" 表示"或"
                        - "a|b" == /[ab]/
                        - "[A-z]" 表示任意字母
                        - "[0-9]" 表示任意数字
                        - "a[bde]c" == abc|adc|aec
                        - "[^ ]" 表示"除了"，找除...以外的字符串
                    · 匹配模式可以为：
                        - "i"：ignore 忽略大小写
                        - "g"：global 全局匹配模式
        b）字面量：
                var reg = /正则表达式/匹配模式; "不用加引号"
    (3) 检查：
                reg.test(被检查值); // true/false
    (4) 量词：
            1) 连续出现n次：/a{n}/
                - 只对前一个内容起作用
                    var reg1 = /ab{3}/;
                    var reg2 = /(ab){3}/
                    console.log(reg1.test(abbb)); // true
                    console.log(reg2.test(ababab)); // true
            2) 连续出现m-n次：/a{m,n}/
            3) 连续出现m次及以上：/a{m,}/
            4) 至少出现1次：/a+/ == /a{1,}/
            5) 出现0次或多次：/a*/ == /a{0,}/
            6) 出现0次或1次：/a?/ == /a{0,1}/
            7) 是否以a开头：/^a/ 
            8) 是否以a结尾：/a$/
                    · /^a$/ ;// a
                      /^a | a$/ ;// axxxxa
    (5) 转义字符
            "."表示任意字符
                -> 使用"\"作为转义字符
                    \. 表示 .
                    \\ 表示 \
                -> 在构造函数中使用\转义字符需要写两遍
                    \\. 表示 .
                    \\\\ 表示 \
                \w == [A-z0-9_]-> 任意字母、数字、下划线
                \W == [^A-z0-9_]-> 除了字母、数字、下划线 
                \d == [0-9] -> 任意数字
                \D == [^0-9] -> 除了数字
                \s == 空格
                \S == 除了空格
                \b == 单词边界
                \B == 除了单词边界
    (6) 去除空格
        - str.replace(/\s/g,""); // 去除所有空格
        - str.replace(/^\s*/,""); // 去除开头空格
        - str.replace(/\s*$/,""); // 去除结尾空格
        - str.replace(/^\s*|\s*$/g,""); // 去除开头和结尾空格
    (7) 应用
        1) 电话号码 18600561973
            1. 以1开头 "^1"
            2. 第二位是3-9 "[3-9]"
            3. 共11位 "[0-9]{9}$"
        2) 邮箱地址 chloe1997_.we0sdf@163.com.cn
            1. 至少三位任意字母数字下划线 "\w{3,}"
            2. .任意字母数字下划线（可有可无） "(\.\w+)*"
            3. @ "@"
            4. 任意字母数字 "[A-z0-9]+"
            5. .任意2-5位字母（重复1-2次） "(\.[A-z]{2,5}){1,2}"

18. DOM(Document Object Model) 文档对象模型
    (1) DOM 定义：JS通过DOM对HTML文档进行操作
            - 文档：整个HTML网页即为文档
            - 对象：将网页中每部分都转换成对象
            - 模型：表示对象之间的关系，方便获取对象
                    文档 - 根元素<html> - 元素节点head - 元素title - 文本节点
                                        - 元素节点body - 元素a - 属性href
    (2) 节点 Node
        - 定义：构成HTML文档最基本的单元（网页中的一切都是节点）
        - 分类：
            · 文档节点：整个HTML文档
            · 元素节点：HTML文档中的HTML标签
            · 属性节点：元素的属性
            · 文本节点：HTML标签中的文本内容
        - 属性（对应上述四种节点）
            1) nodeName; #document 标签名 属性名 #text
            2) nodeType; 9 1 2 3
            3) nodeValue; null null 属性值 文本内容
    (3) 利用DOM获取页面元素
        · 浏览器已经为我们提供了文档节点对象window属性，可直接在页面中使用，代表整个网页
        · 常用方法：
                - innerHTML：内部代码
                - innerText：内部代码（自动去除html标签版）
                - value：文本框的value是文本框中填写的内容
            "获取元素节点"
                - getElementById("") 通过id获取一个元素节点对象
                - getElementsByTagName("") 通过标签名获取一组元素节点对象 "返回类数组对象"
                - getElementsByName("") 通过name属性标签获取一组元素节点对象 "返回类数组对象"
                - getElementsByClassName("") 根据属性值获取一组元素节点对象 仅支持ie9以上
                - document.querySelector("") 根据CSS选择器查询"一个"元素节点对象 只返回第一个
                - document.querySelectorAll("") 根据CSS选择器查询"一组"元素节点对象 "返回数组对象"
            "获取元素节点的子节点"
                - getElementsByTagName("")方法：返回当前节点的指定标签名后代节点
                - children属性：当前元素的所有子元素 -> 不包括空白节点
                - childNodes属性：当前节点的所有子节点 -> 包括空白节点
                - firstChild属性：当前节点的第一个子节点 -> 包括空白节点
                - lastChild属性：当前节点的最后一个子节点 -> 包括空白节点
            "获取元素父节点和兄弟节点"
                - parentNode属性：当前节点的父节点
                - previousSibling属性：当前节点的前一个兄弟节点 -> 包括空白节点
                - nextSibling属性：当前节点的后一个兄弟节点 -> 包括空白节点
                - previous/nextElementSibling：获取元素 -> 仅支持ie8以上
        · 读取元素属性："元素.属性名"
            - class属性不能采用这种方式（保留字）-> 元素.className
        · 获取body标签："document.body" -> 保留的是body的引用
        · 获取html标签："documentElement" -> 对应html根标签
        · 获取页面中所有元素："document.all" == "document.getElementsByTagName('*')"
        · DOM增删改的方法
            document.createElement(element)	    创建 HTML 元素
            document.removeChild(element)	    删除 HTML 元素 -> element.parentNode.removeChild(子节点);
            document.appendChild(element)	    添加 HTML 元素 -> 向父节点中添加一个子节点
            document.replaceChild(new, old)	    替换 HTML 元素
            document.write(text)	            写入 HTML 输出流
            element.innerHTML = new html content    改变元素的 inner HTML
            element.attribute = new value     	    改变 HTML 元素的属性值
            element.setAttribute(attribute, value)  改变 HTML 元素的属性值
            element.style.property = new style	    改变 HTML 元素的样式
            element.insertBefore(new value, ref)    在ref前插入新节点
    (4) 事件
        · 文档或浏览器窗口中发生的特定的交互瞬间
        · 处理事件：
            - 在事件对应标签的属性中设置代码
            - 为事件绑定处理函数 （响应函数）
    (5) 加载顺序
        · 浏览器加载页面时自上向下顺序加载
            - 将js代码写在head标签中 -> "window.onload(){}"
            - 将js代码写在body标签中 -> "写在html下"
            - for循环先执行，响应函数在交互时才执行
    (6) 注意事项
        · <a>标签：
            - 点击超链接会自动跳转页面 ——> 删除默认行为：
                - return false
                - href = "javascript:;"
    (7) 利用DOM操作CSS样式
            1）style属性
                · 语法："元素.style.样式名 = 样式值"
                    - 含有-的样式名要改成驼峰命名法：去掉-，字母大写
                    - 通过style属性设置的样式都为内联样式，除了!important以外优先级最高
                    - 通过style属性读取的样式都为内联样式，无法读取样式表中的样式
            2）currentStyle ; 只有ie能用
                · 语法："元素.currentStyle.样式名 = 样式值"
                    - 读取当前元素正在显示的样式
                    - 未设置样式则显示默认值
            3）getComputedStyle() ; window的方法，用来获取元素当前样式
                · 语法：(getComputedStyle(元素1，元素2)).样式名
                    - 元素1：要获取样式的元素 
                    - 元素2：可以传递一个伪元素，一般都为null
                    - 返回一个对象，封装当前元素对应的样式
                    - 未设置样式则获取当前真实值
                    - 只读，不能修改
                        ; 获取元素style值的方法：
                        function getStyle(obj, name){
                            if(window.getComputedStyle){
                                return getComputedStyle(obj, null)[name];
                            }else{
                                return obj.currentStyle[name];
                            }
                        }  
            4）常用属性
                · clientWidth / clientHeight
                    - 获取可见宽度/高度，包括内容区和内边距（不包括边框）
                    - 返回数值，不带单位
                    - 只读，不能修改
                · offsetWidth / offsetHeight
                    - 获取整个宽度/高度，包括内容区、内边距和边框
                · offsetParent
                    - 获取离得最近的，开启了定位的祖先元素
                · offsetLeft / offsetTop
                    - 获取相对于其定位元素的水平/垂直偏移量
                · scrollWidth / scrollHeight
                    - 获取滚动区域宽度/高度
                · scrollLeft / scrollTop
                    - 获取水平/垂直滚动条滚动的距离
                    - scrollHeight - scrollTop == clientHeight时，滚动条到底了
                · onscroll 拖动滚轮
                · onmousemove 鼠标移动
            5）修改class改变css：
                obj.className += " newClassName";
                    - 定义函数，用来向元素中添加指定的class属性值
                    function addClass(obj,cn){
                        if(!hasClass(obj,"className")){
                            obj.className += " " + cn;
                        }
                    }
                    - 定义函数，判断元素中是否含有class值
                    function hasClass(obj,cn){
                        var reg = new RegExp("\\b"+cn+"\\b");
                        return reg.test(obj.className);
                    }
                    - 定义函数，用来删除元素中的指定class属性值
                    function removeClass(obj,cn){
                        var reg = new RegExp("\\b"+cn+"\\b");
                        obj.className = obj.className.replace(reg,"");
                    }
                    -定义函数，用来切换元素中的类
                        ; 有就删除，没有就添加
                    function toggleClass(obj,cn){
                        if(hasClass(obj,cn)){
                            removeClass(obj,cn);
                        }else{
                            addClass(obj,cn);
                        }
                    }

                    

    (8) Dom事件Event
        - 事件响应函数被触发时，浏览器每次都会将一个时间对象作为实参传递给响应函数
        - clientX / clientY：鼠标在"当前可见窗口"的水平/垂直坐标
        - pageX / pageY：鼠标"相对于当前页面"的水平/垂直坐标
    (9) 事件的冒泡
        · 事件的向上传导，后代元素事件被触发时，祖先元素的"相同事件"也会被触发
        · 可通过"事件对象"取消冒泡：event.cancelBubble = true;
        · 应用：事件的委派
            - 把事件绑定给祖先元素 
            - target：event中的target表示触发事件的对象
                祖先元素.onclick = function(event){
                    if(event.target.className == "class"){}
                }
    (10) 事件的绑定
        · 使用 "对象.事件=函数" 的形式绑定只能同时为一个事件绑定一个响应函数
        · 使用 addEventLitsener(参数1，参数2，参数3)方法：
            - 参数1 eventStr：事件的字符串，不要加on
            - 参数2 callback：回调函数
            - 参数3 boolean：表示是否在捕获阶段触发事件，一般传false
                btn.addEventListener("click",function(){
                    alert("可以同时绑定多个响应函数");
                },false);
                "bind()函数"
                function bind(obj, eventStr, callback){
                    obj.addEventListener(eventStr, callback, false);
                }
    (11) 事件的传播
        · 捕获阶段：从祖先元素向内捕获，但不触发事件
        · 目标阶段：捕获到目标元素，并触发当前事件
        · 冒泡阶段：从目标元素向祖先元素依次触发事件
            - 将addEventListener()第三个参数设置为true -> 在捕获阶段触发事件
    (12) 鼠标事件
        · 鼠标点击事件
            - onmousemove / onmousedown / onmouseup
        · 鼠标滚轮事件
            - onmousewheel 
                1）"应对浏览器不支持问题："
                    obj.onmousewheel = function(){};
                    bind(obj, "DOMMouseScroll", obj.onmousewheel);
                2）滚动方向(只看正负，不看大小)
                    event.wheelDelta属性和event.detail属性
                        if(event.wheelDelta > 0 || event.detail < 0){}
        · 键盘事件
            "一般绑定给能获取到焦点的对象或是document"
                - onkeydown 按下按键
                - onkeyup 松开按键
                    ; keyCode：获取键盘编码
                    ; altKey / ctrlKey / shiftKey：是否按下这三个功能键
                - 利用输入框默认功能禁止输入数字：
                    input.onkeydown = function(event){
                        if(event.keyCode >= 48 && event.keyCode <= 57){
                            return false;
                        }
                    }

19. BOM(Browser Object Model) 浏览器对象模型
    (1) 作用：BOM中提供了一组对象，用来操作浏览器
    (2) 对象："均作为window对象的属性保存，可以直接使用"
        - Window
            · 代表整个浏览器窗口，window为网页中全局对象
                ; setInterval(function(){},1000)方法：
                    - 开启定时调用，每隔一段"时间"(单位毫秒)执行一次"函数"
                    - 返回值：返回一个Number作为定时器的标识
                    - clearInterval(定时器返回值); 关闭定时器
                        "可以传任何类型参数，不报错"
                        "开启定时器前需要把当前元素的其他定时器关闭"
                ; setTimeout(function(){},1000)方法：
                    - 开启延时调用，隔一段"时间"后执行一次"函数"
                    - clearTimeout(延时调用返回值);关闭延时调用
        - Navigator
            · 代表浏览器的信息，通过该对象可以识别不同浏览器
            · 由于历史原因，大部分Navigator中属性已不能用于识别浏览器除了 ——>
                userAgent：一个字符串，包含浏览器信息
                ; 判断浏览器：
                    if(/firefox/i.test(navigator.userAgent)){
                    }else if(/chrome/i.test(navigator.userAgent)){
                    }else if(/msie/i.test(navigator.userAgent)){
                    }else if("ActiveXObject" in window){}
        - Location
            · 代表浏览器地址栏信息，可以获取地址栏或操作浏览器跳转页面
                - 直接打印location -> 获取当前页面完整路径
                - location = "相对路径/完整路径" -> 跳转到该路径并生成历史记录
                - assign("相对路径/王正路径")方法：跳转到其他页面并生成历史记录
                - reload(true)方法：重新加载页面，等于刷新按钮; 传true则清空缓存
                - replace()方法：替换成其他页面且不生成历史记录
        - History
            · 代表浏览器历史记录，不可访问具体历史，只能操作向前或向后翻页，仅当次访问有效
                - length属性：获取当前访问的链接数量
                - history.back()方法：回退到上一个页面
                - history.forward()方法：前进到下一个页面
                - history.go(n)方法：向前或向后跳转n个页面，正数向前负数向后
        - Screen
            · 代表用户屏幕的信息，可获取显示器信息

20. JSON "Javascript Object Notation "
    - JSON和JS对象格式一样，但是字符串中的属性名必须加双引号
        var obj = '{"name":"Chloe","age":25,"hobby":"dormir"}';
    - JSON分类：
        · 对象{}
        · 数组[]
    - JSON数值：
        · 字符串
        · 数值
        · 布尔值
        · null
        · 对象
        · 数组
    - 转换：利用JSON工具类将JSON和JS对象相互转化
        JSON -> JS object
            ; JSON.parse()
                var json = '{"name":"Chloe"}';
                var o = JSON.parse(json);
                console.log(o.name); // Chloe
        JS object -> JSON
            ; JSON.stringify()
                var obj = {name:"Chloe"};
                var o = JSON.stringify(obj);
                console.log(o); // '{"name":"Chloe"}'
        兼容ie7：
            ; eval() 函数执行代码
            ; 如果字符串中包含{} 则被认定为代码块
                ——> 前后加()避免被读成代码块
                ——> 尽量不用该函数，安全性差
                var str = {name:"Chloe"};
                var obj = eval("("+str+")");
                console.log(obj); // '{"name":"Chloe"}'
            ; 引入json tool文件
----------------------------------------------------------------------------
"进度条"
2022-03-02 bilibili HAN P41 闭包含数的应用
2022-03-03 bilibili HAN P43 对象
2022-03-04 bilibili HAN P47 JS的类
2022-03-14 bilibili HAN P50 数组
2022-03-15 bilibili HAN P53 数组的方法01
2022-03-16 bilibili HAN P56 数组的方法es6新增
2022-03-24 bilibili HAN P57 数组迭代
2022-04-14 bilibili HAN P59 12:50 数组的冒泡排序
2022-04-15 bilibili HAN P60 冒泡排序的封装
2022-04-26 bilibili HAN P62 数组去重值splice的方法
2022-06-28 bilibili HAN P64 多维数组
2022-06-29 bilibili HAN P65 二级联动
2022-06-30 bilibili HAN P66 字符串的创建
2022-07-01 bilibili HAN P68 字符串的拼接方法
2022-07-04 bilibili HAN P71 字符串HTML包装的方法
2022-07-05 bilibili HAN P72 转义字符
----------------暂停----------------
2022-07-05 bilibili 尚硅谷 P15 运算符
2022-07-06 bilibili 尚硅谷 P21 赋值运算符
2022-07-07 bilibili 尚硅谷 P22 关系运算符
2022-07-08 bilibili 尚硅谷 P25 条件运算符
2022-07-11 bilibili 尚硅谷 P41 嵌套的for循环
2022-07-12 bilibili 尚硅谷 P51 函数的引用
2022-07-13 bilibili 尚硅谷 P58 全局作用域
2022-07-14 bilibili 尚硅谷 P61 this
2022-07-15 bilibili 尚硅谷 P70 数组简介
2022-07-18 bilibili 尚硅谷 P84 字符串的方法
2022-07-19 bilibili 尚硅谷 P96 DOM查询
2022-07-20 bilibili 尚硅谷 P103 DOM删除
2022-07-25 bilibili 尚硅谷 P113 事件的冒泡
2022-07-26 bilibili 尚硅谷 P125 BOM History
2022-07-27 bilibili 尚硅谷 P131 定时器的应用
2022-07-28 bilibili 尚硅谷 P137 类的操作
---------------JS初级 完结撒花--------------
https://codeofli.github.io/2019/11/js-note/javaScript/javaScript/
----------------------------------------------------------------------------
;// 常用函数  
    · parseFloat()           转换为浮点（小数）类型
    · parseInt()             转换为整数类型
    · document.write("")     向body中输出内容
    · Number.MAX_VALUE       JS中最大值
    · Number.MIN_VALUE       JS中最小值
    · typeof()               判断数据类型
    · A instanceof B         判断A是否为B的引用
    · isNaN()                转换为number后确定值是否为非数字
    · Number.isNaN()         检查值是否为NaN
    · prompt()               输入值会作为函数返回值返回，可以定义一个变量来接收该内容 
                             "返回值为string"
    · console.time()         优化测时间 - 计时开始
    · console.timeEnd()      优化测试时间 - 计时结束
    · Math.sqrt()            开根号
    · xxx.add(option, before)添加元素 before不存在时往末尾添加
    · xxx.add(new Option(text, value, true, true))
                             添加元素 -> 动态创建选项
    · new Date()             当前代码执行的日期时间
      new Date("07/18/2022 15:48:20")
                             指定的日期时间

----------------------------------------------------------------------------
;// 常见报错
    · ...is not defined                 未对...进行声明
    · ...is undefined                   ...已声明未赋值
    · undefined is not a function       正在调用的值并非函数

----------------------------------------------------------------------------
;// 常用格式
    (1) 
    (2) 
    (3) 
    (4) 
    (5) 